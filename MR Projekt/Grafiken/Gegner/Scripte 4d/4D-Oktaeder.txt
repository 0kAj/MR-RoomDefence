import bpy
import mathutils
import math
import itertools

# Szene leeren
bpy.ops.object.select_all(action='SELECT')
bpy.ops.object.delete(use_global=False)

# Erzeuge Ecken des 4D Oktaeders (16-Zeller):
# Alle Vektoren mit einer ±1 und rest 0, also (±1,0,0,0) plus Permutationen
def generate_4d_octahedron_vertices():
    base = [1, 0, 0, 0]
    vertices = []
    for perm in set(itertools.permutations(base)):
        vertices.append(mathutils.Vector(perm))
        vertices.append(mathutils.Vector(tuple(-x for x in perm)))
    return vertices

def project_4d_to_3d(v4, distance=4.0):
    w_diff = distance - v4.w
    if abs(w_diff) < 1e-6:
        w_diff = 1e-6
    factor = distance / w_diff
    return mathutils.Vector((v4.x * factor, v4.y * factor, v4.z * factor))

def create_sphere(location, radius=0.1, name="Corner"):
    bpy.ops.mesh.primitive_uv_sphere_add(radius=radius, location=location)
    obj = bpy.context.object
    obj.name = name
    return obj

def create_edge(start, end, width=0.03, name="Edge"):
    direction = end - start
    length = direction.length
    mid = (start + end) / 2
    bpy.ops.mesh.primitive_cube_add(size=1, location=mid)
    edge = bpy.context.object
    edge.name = name
    edge.scale = (width, width, length / 2)
    direction = direction.normalized()
    rot_quat = direction.to_track_quat('Z', 'Y')
    edge.rotation_mode = 'QUATERNION'
    edge.rotation_quaternion = rot_quat
    return edge

def rotation_4d(v, angle, i, j):
    # Rotiert Vektor v in 4D in Ebene i-j (0=x,1=y,2=z,3=w)
    coords = [v.x, v.y, v.z, v.w]
    c = math.cos(angle)
    s = math.sin(angle)
    x_i = coords[i] * c - coords[j] * s
    x_j = coords[i] * s + coords[j] * c
    coords[i] = x_i
    coords[j] = x_j
    return mathutils.Vector(coords)

# Vertices und Kanten generieren
vertices_4d = generate_4d_octahedron_vertices()
print(f"Generierte {len(vertices_4d)} Ecken.")

# Kanten des 16-Zellers: verbinden Punkte mit Abstand sqrt(2)
edges = []
n = len(vertices_4d)
for i in range(n):
    for j in range(i+1, n):
        dist = (vertices_4d[i] - vertices_4d[j]).length
        # Abstand sqrt(2) ≈ 1.414 verbindet Kanten beim 16-Zeller
        if math.isclose(dist, math.sqrt(2), abs_tol=1e-6):
            edges.append((i, j))

print(f"Gefundene Kanten: {len(edges)}")

# Objekte erstellen
spheres = []
edges_objs = []

sphere_radius = 0.1
edge_width = 0.03

for i, v in enumerate(vertices_4d):
    p3d = project_4d_to_3d(v)
    s = create_sphere(p3d, sphere_radius, name=f"Corner_{i}")
    spheres.append(s)

for i, (start_idx, end_idx) in enumerate(edges):
    p_start = project_4d_to_3d(vertices_4d[start_idx])
    p_end = project_4d_to_3d(vertices_4d[end_idx])
    e = create_edge(p_start, p_end, edge_width, name=f"Edge_{i}")
    edges_objs.append(e)

# Animation Handler
def animate_4d_octahedron(scene):
    frame = scene.frame_current
    angle = frame * 0.03

    # Rotation in Z-W Ebene (Index 2 und 3)
    rotated_vertices = [rotation_4d(v, angle, 2, 3) for v in vertices_4d]
    projected = [project_4d_to_3d(v) for v in rotated_vertices]

    for i, v3d in enumerate(projected):
        spheres[i].location = v3d

    for i, (start_idx, end_idx) in enumerate(edges):
        start = projected[start_idx]
        end = projected[end_idx]

        obj = edges_objs[i]
        obj.location = (start + end) / 2

        direction = end - start
        length = direction.length
        obj.scale = (edge_width, edge_width, length / 2)

        direction = direction.normalized()
        rot_quat = direction.to_track_quat('Z', 'Y')
        obj.rotation_mode = 'QUATERNION'
        obj.rotation_quaternion = rot_quat

bpy.app.handlers.frame_change_pre.clear()
bpy.app.handlers.frame_change_pre.append(animate_4d_octahedron)

scene = bpy.context.scene
scene.frame_start = 1
scene.frame_end = 250
scene.frame_set(1)

print("Animation des 4D-Oktaeders (16-Zeller) fertig! Starte die Timeline.")
