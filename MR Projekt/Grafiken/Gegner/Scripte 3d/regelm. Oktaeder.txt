import bpy
import mathutils
import math

# Szene leeren
bpy.ops.object.select_all(action='SELECT')
bpy.ops.object.delete(use_global=False)

# Eckpunkte eines regelmäßigen Oktaeders (zentriert am Ursprung)
vertices = [
    mathutils.Vector((1, 0, 0)),
    mathutils.Vector((-1, 0, 0)),
    mathutils.Vector((0, 1, 0)),
    mathutils.Vector((0, -1, 0)),
    mathutils.Vector((0, 0, 1)),
    mathutils.Vector((0, 0, -1))
]

# Kanten des Oktaeders (je zwei verbundene Eckpunkt-Indizes)
edges = [
    (0, 2), (0, 3), (0, 4), (0, 5),
    (1, 2), (1, 3), (1, 4), (1, 5),
    (2, 4), (2, 5),
    (3, 4), (3, 5)
]


# Parameter
sphere_radius = 0.15
edge_width = 0.08

# Funktion zum Erstellen einer Kugel
def create_sphere(location, radius, name="Sphere"):
    bpy.ops.mesh.primitive_uv_sphere_add(radius=radius, location=location)
    sphere = bpy.context.object
    sphere.name = name
    return sphere

# Funktion zum Erstellen eines Quaders (Kante) zwischen zwei Punkten
def create_edge(start, end, width=0.05, name="Edge"):
    direction = end - start
    length = direction.length
    mid = (start + end) / 2
    bpy.ops.mesh.primitive_cube_add(size=1, location=mid)
    edge = bpy.context.object
    edge.name = name

    # Skalieren und Ausrichten
    edge.scale = (width, width, length / 2)
    direction = direction.normalized()
    rot_quat = direction.to_track_quat('Z', 'Y')
    edge.rotation_mode = 'QUATERNION'
    edge.rotation_quaternion = rot_quat
    return edge

# Ecken als Kugeln erstellen
for i, v in enumerate(vertices):
    create_sphere(v, sphere_radius, name=f"Corner_{i}")

# Kanten als Rechtecke erstellen
for i, (start_idx, end_idx) in enumerate(edges):
    start = vertices[start_idx]
    end = vertices[end_idx]
    create_edge(start, end, edge_width, name=f"Edge_{i}")
