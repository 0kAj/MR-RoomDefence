import bpy
import mathutils
import math

# Szene leeren
bpy.ops.object.select_all(action='SELECT')
bpy.ops.object.delete(use_global=False)

# W체rfel-Eckpunkte definieren (Einheitsw체rfel zentriert bei Ursprung)
vertices = [
    mathutils.Vector((1, 1, 1)),
    mathutils.Vector((-1, 1, 1)),
    mathutils.Vector((-1, -1, 1)),
    mathutils.Vector((1, -1, 1)),
    mathutils.Vector((1, 1, -1)),
    mathutils.Vector((-1, 1, -1)),
    mathutils.Vector((-1, -1, -1)),
    mathutils.Vector((1, -1, -1))
]

# Kanten: je zwei Indizes aus der vertices-Liste
edges = [
    (0, 1), (1, 2), (2, 3), (3, 0),  # obere Fl채che
    (4, 5), (5, 6), (6, 7), (7, 4),  # untere Fl채che
    (0, 4), (1, 5), (2, 6), (3, 7)   # vertikale Kanten
]

# Parameter
sphere_radius = 0.15
edge_width = 0.08

# Funktion zum Erstellen einer Kugel
def create_sphere(location, radius, name="Sphere"):
    bpy.ops.mesh.primitive_uv_sphere_add(radius=radius, location=location)
    sphere = bpy.context.object
    sphere.name = name
    return sphere

# Funktion zum Erstellen eines Quaders (Kante) zwischen zwei Punkten
def create_edge(start, end, width=0.05, name="Edge"):
    direction = end - start
    length = direction.length
    mid = (start + end) / 2
    bpy.ops.mesh.primitive_cube_add(size=1, location=mid)
    edge = bpy.context.object
    edge.name = name

    # Skalieren und Ausrichten
    edge.scale = (width, width, length / 2)
    direction = direction.normalized()
    rot_quat = direction.to_track_quat('Z', 'Y')
    edge.rotation_mode = 'QUATERNION'
    edge.rotation_quaternion = rot_quat
    return edge

# Ecken als Kugeln erstellen
for i, v in enumerate(vertices):
    create_sphere(v, sphere_radius, name=f"Corner_{i}")

# Kanten als Rechtecke erstellen
for i, (start_idx, end_idx) in enumerate(edges):
    start = vertices[start_idx]
    end = vertices[end_idx]
    create_edge(start, end, edge_width, name=f"Edge_{i}")
