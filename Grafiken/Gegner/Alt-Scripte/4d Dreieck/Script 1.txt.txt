import bpy
import math
import mathutils
from itertools import combinations
import numpy as np

# ---------- Parameter ----------
frames = 120
rotation_speed = 2 * math.pi / frames
projection_distance = 4.0
point_radius = 0.08
edge_thickness = 0.03

# ---------- 4D Pentachoron-Punkte ----------
pentachoron_4d = [
    (1, 1, 1, -1/np.sqrt(5)),
    (1, -1, -1, -1/np.sqrt(5)),
    (-1, 1, -1, -1/np.sqrt(5)),
    (-1, -1, 1, -1/np.sqrt(5)),
    (0, 0, 0, 4/np.sqrt(5))
]

# ---------- Funktionen ----------

def rotate_4d(p, angle, axis1, axis2):
    a, b = p[axis1], p[axis2]
    c, s = math.cos(angle), math.sin(angle)
    p = list(p)
    p[axis1] = a * c - b * s
    p[axis2] = a * s + b * c
    return tuple(p)

def project_to_3d(p4, distance=4.0):
    x, y, z, w = p4
    factor = 1 / (distance - w)
    return (x * factor, y * factor, z * factor)

def create_edge_box(p1, p2, thickness=0.05, name="EdgeBox"):
    start = mathutils.Vector(p1)
    end = mathutils.Vector(p2)
    center = (start + end) / 2
    direction = end - start
    length = direction.length

    bpy.ops.mesh.primitive_cube_add(size=1)
    obj = bpy.context.object
    obj.name = name
    obj.scale = (thickness, thickness, length / 2)

    up = mathutils.Vector((0, 0, 1))
    quat = up.rotation_difference(direction.normalized())
    obj.rotation_mode = 'QUATERNION'
    obj.rotation_quaternion = quat
    obj.location = center

    return obj

# ---------- Szene leeren ----------
bpy.ops.object.select_all(action='SELECT')
bpy.ops.object.delete(use_global=False)

# ---------- Kanten berechnen ----------
edges = list(combinations(range(len(pentachoron_4d)), 2))  # 10 Kanten

# ---------- Sphären erzeugen ----------
spheres = []
for p4 in pentachoron_4d:
    p3 = project_to_3d(p4, projection_distance)
    bpy.ops.mesh.primitive_uv_sphere_add(radius=point_radius, location=p3)
    spheres.append(bpy.context.object)

# ---------- Kantenobjekte (Quader) erzeugen ----------
edge_objects = []
for i, j in edges:
    p1 = project_to_3d(pentachoron_4d[i], projection_distance)
    p2 = project_to_3d(pentachoron_4d[j], projection_distance)
    obj = create_edge_box(p1, p2, thickness=edge_thickness, name=f"Edge_{i}_{j}")
    edge_objects.append((obj, i, j))

# ---------- Animation ----------
for frame in range(frames):
    angle = frame * rotation_speed
    rotated = []

    # Kombinierte Rotation in mehreren Ebenen (4D!)
    for p4 in pentachoron_4d:
        p = rotate_4d(p4, angle, 0, 3)  # x-w
        p = rotate_4d(p, angle, 1, 2)   # y-z
        rotated.append(project_to_3d(p, projection_distance))

    # Update Punkte (Sphären)
    for i, pos in enumerate(rotated):
        spheres[i].location = pos
        spheres[i].keyframe_insert(data_path="location", frame=frame)

    # Update Kanten (Quader)
    for obj, i1, i2 in edge_objects:
        p1 = mathutils.Vector(rotated[i1])
        p2 = mathutils.Vector(rotated[i2])
        center = (p1 + p2) / 2
        direction = p2 - p1
        length = direction.length

        obj.scale = (edge_thickness, edge_thickness, length / 2)
        up = mathutils.Vector((0, 0, 1))
        quat = up.rotation_difference(direction.normalized())
        obj.rotation_quaternion = quat
        obj.location = center

        obj.keyframe_insert(data_path="location", frame=frame)
        obj.keyframe_insert(data_path="rotation_quaternion", frame=frame)
        obj.keyframe_insert(data_path="scale", frame=frame)

print("✅ Pentachoron (4D-Simplex) animiert in Blender!")
