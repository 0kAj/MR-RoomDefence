import bpy
import math
from itertools import product

# ---------- Parameter ----------
frames = 100
rotation_speed = 2 * math.pi / frames  # 1 volle Rotation
projection_distance = 3.0
point_radius = 0.05

# ---------- Funktionen ----------

def rotate_4d(point, angle, axis1, axis2):
    """ Rotiert 4D-Punkt in der Ebene (axis1, axis2) """
    p = list(point)
    a, b = p[axis1], p[axis2]
    c, s = math.cos(angle), math.sin(angle)
    p[axis1] = a * c - b * s
    p[axis2] = a * s + b * c
    return tuple(p)

def project_to_3d(p4, distance=3.0):
    """ Perspektivische 4D->3D Projektion """
    x, y, z, w = p4
    factor = 1 / (distance - w)
    return (x * factor, y * factor, z * factor)

# ---------- Vorbereitungen ----------

# Szene leeren
bpy.ops.object.select_all(action='SELECT')
bpy.ops.object.delete(use_global=False)

# Alle 16 Ecken des 4D-Tesserakts
vertices_4d = [p for p in product([-1, 1], repeat=4)]

# Erzeuge Sphären an den projizierten Positionen
spheres = []
for p4 in vertices_4d:
    x, y, z = project_to_3d(p4, projection_distance)
    bpy.ops.mesh.primitive_uv_sphere_add(radius=point_radius, location=(x, y, z))
    obj = bpy.context.object
    spheres.append(obj)

# ---------- Animation ----------

for frame in range(frames):
    angle = frame * rotation_speed

    for i, p4 in enumerate(vertices_4d):
        # 4D-Rotation (kombiniert)
        p_rot = rotate_4d(p4, angle, 0, 3)  # x-w Rotation
        p_rot = rotate_4d(p_rot, angle, 1, 2)  # y-z Rotation

        # 4D → 3D Projektion
        x, y, z = project_to_3d(p_rot, projection_distance)

        # Sphäre bewegen und Keyframe setzen
        obj = spheres[i]
        obj.location = (x, y, z)
        obj.keyframe_insert(data_path="location", frame=frame)

print("✅ Tesserakt-Animation erstellt!")
